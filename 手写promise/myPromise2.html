<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPromise2</title>
</head>
<body>
    
    <script>

        class MyPromise {
            constructor (hander) { // 传入一个参数，为函数，立即执行
                if(typeof hander !== 'function'){ // 判断传入的参数是否为函数
                    throw new TypeError('Promise resolver undefined is not a function');
                }

                this._status = 'padding'; // 定义初始状态，另外成功状态为 fulfilled, 失败状态为 rejected.
                this._value = undefined; // 定义成功状态值,初始值为undefined
                this._reason = undefined; // 定义失败状态值,初始值为undefined
                this.onResolvedCallbacks = []; // 成功的回调函数
                this.onRejectedCallbacks = []; //失败的回调函数

                // 执行hander函数
                try {
                    hander(this._resolve.bind(this), this._reject.bind(this)); // 此处bind不懂
                } catch (error) {
                    this._reject(error);
                }
            }

            // 定义resolve函数
            _resolve(value){
                if(this._status !== 'padding'){ // 非pandding状态下 不可推出下一个状态
                    return;
                }
                this._status = 'fulfilled';
                this._value = value;
                this.onResolvedCallbacks.forEach(fn => fn());
            }

            // 定义reject函数
            _reject(value){
                if(this._status !== 'padding'){ // 非pandding状态下 不可推出下一个状态
                    return;
                }
                this._status = 'rejected';
                this._reason = value;
                this.onRejectedCallbacks.forEach(fn => fn());
            }

            // then方法
            then(res, rej){
                // 如果then方法没传函数
                var fulfilled = typeof res == 'function' ? res : function(data){ return data; }
                var rejected = typeof rej == 'function' ? rej : function(data){ throw new Error(data) }

                let { _status, _value, _reason } = this;

                return new MyPromise((onFulfilledNext, onRejectedNext) => { // then 返回一个promise
                    let x; // 保存当前的状态值，方便链式调用

                    switch (_status) {
                        case 'fulfilled': // 推向成功
                            x = fulfilled(_value); // 执行当前then函数且保存
                            onFulfilledNext(x);
                            break;
                        case 'rejected': // 推向失败
                            x = rejected(_reason);
                            onRejectedNext(x);
                            break;
                        case 'padding': // padding 处于padding状态就把
                            this.onResolvedCallbacks.push(() => {
                                x = fulfilled(_value);
                                onFulfilledNext(x);
                            });
                            this.onRejectedCallbacks.push(() => {
                                x = rejected(_reason);
                                onFulfilledNext(x);
                            });
                    }
                })
                
            }
        }

        var pro1 = new MyPromise((res, rej) => {
            res(1)
        });
        var pro2 = new MyPromise((res, rej) => {
            res(pro1)
        });
        var pro3 = new MyPromise((res, rej) => {
            res(pro2);
        });
        pro3.then((res) => {
            console.log(res instanceof MyPromise);
        }, (err) => {
            console.log(err);
        })

        var pro11 = new Promise((res, rej) => {
            res(1)
        });
        var pro22 = new Promise((res, rej) => {
            res(pro11)
        });
        var pro33 = new Promise((res, rej) => {
            res(pro22);
        });
        pro33.then((res) => {
            console.log(res instanceof Promise);
            console.log(res);
        }, (err) => {
            console.log(err);
        })

        // 多层返回promise类型最终返回正常的值问题

    </script>

</body>
</html>